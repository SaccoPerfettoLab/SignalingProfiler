---
title: "SignalingProfiler 2.0 tutorial"
author: "[SaccoPerfettoLab](https://github.com/https://github.com/SaccoPerfettoLab/)"
date: "Last updated: `r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    css: style.css
    theme: united
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
    toc_depth: 3
    number_sections: false
    code_folding: hide
    code_download: true
bibliography: references.bib
link-citations: true
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  cache = FALSE,
  echo = TRUE,
  warning = FALSE,
  error = FALSE,
  message = FALSE,
  collapse = TRUE,
  comment = "#"
)
```

```{r klippy, echo=FALSE, include=TRUE}
klippy::klippy()
```

```{r Load libraries, message = FALSE, include = FALSE}
library(DT)
library(ggplot2)
library(xfun)
library(SignalingProfiler)
library(tidyverse)
```

# Introduction {.unnumbered}

SignalingProfiler 2.0 is a modelling pipeline described in [Venafra et al., 2024](https://www.biorxiv.org/content/10.1101/2024.01.25.577229v1.full.pdf).

> The **SignalingProfiler** package provides a flexible way to create signaling networks integrating transcriptomic, proteomic and phosphoproteomic data.

Briefly, the method allows the user to build a mechanistic model representing the signal remodeling upon a treatment or in a disease condition. The model starts with perturbed receptor(s) and ends with proteins whose activity is modulated (up- or down-regulated) among your two conditions (e.g. treated vs untreated, disease vs healthy).

> The **SignalingProfiler** pipeline is modular. You can exploit the method to just perform one of the proposed tasks.

The pipeline is divided in three main steps:

-   [**Step 1**](#s1.-infer-protein-activities-from-multi-omics-data): infer the activity of key signaling proteins from multi-omics data;

-   [**Step 2**](#s2-connect-inferred-proteins-in-a-causal-network): connect proteins in a context-specific network;

-   [**Step 3**](#s3-connect-phenotypes-to-the-final-model): connect phenotypes to the final model to make it functionally interpretable;

At the end of the pipeline, you can extract [**functional circuits**](#functional-circuits) connecting perturbed nodes to crucial phenotypes for your context.

# Installation

```{r eval = FALSE, echo = TRUE}
devtools::install_github('https://github.com/SaccoPerfettoLab/SignalingProfiler/')
```

## Prerequisites: ILP Solver

The most important prerequisites for SignalingProfiler 2.0 is the **ILP solver** required by CARNIVAL algorithm[^1] to optimize your model against experimental data. An exhaustive guide about installation can be found in *Prerequisites* section of CARNIVAL GitHub page [here](https://saezlab.github.io/CARNIVAL/).

[^1]: Melas IN, Sakellaropoulos T, Iorio F, Alexopoulos L, Loh WY, Lauffenburger DA, Saez-Rodriguez J, Bai JPF. (2015). Identification of drug-specific pathways based on gene expression data: application to drug induced lung injury. Integrative Biology, Issue 7, Pages 904-920, <https://doi.org/10.1039/C4IB00294F>.

# SignalingProfiler 2.0 input

SignalingProfiler requires processed tables derived from your multi-omics data. Here, we describe the information needed by the package.

> Transcriptomics and Proteomics

Your transcriptomics and proteomics tables should contain the following columns:

-   [**gene_name**]{style="color:orange"} and [**Uniprot ID**]{style="color:orange"} for proteomics; SignalingProfiler is structured having the gene_name as key;

-   [**difference**]{style="color:orange"}: representing the fold-change in gene expression among two conditions; e.g. the difference between treated and control sample;

The next columns regards parameters linked to the statistical test performed among your conditions:

-   [**logpval**]{style="color:orange"}: the p-value associated to your fold-change;

-   [**significant**]{style="color:orange"}: a column containing a '+' if the gene is significantly modulated, NA otherwise;

::: {#Table1}
Transcriptomics data example
:::

```{r}
DT::datatable(tr_toy_df, options = list(pageLength = 3))
```

::: {#Table2}
Proteomics data example
:::
```{r}
DT::datatable(prot_toy_df, options = list(pageLength = 3))
```
> Phosphoproteomics

Before using Signaling Profiler, you have to accurately process you phosphoproteomic data set. The most important step is to have **ONLY ONE OCCURENCE OF EACH PHOSPHOSITE**. If you have a phosphosite quantified more than once, you have to choose the most reliable quantification (usually the lowest multiplicity).

Your phosphoproteomics table should contain:

-   [**UniProt ID**]{style="color:orange"} and [**gene_name**]{style="color:orange"}: reporting the UNIPROT ID and the gene name respectively; again, choose just one gene name.

-   [**aminoacid**]{style="color:orange"} and [**position**]{style="color:orange"}: reporting the phosphosite with the single letter notation and the position in the protein sequence;

-   [**sequence window**]{style="color:orange"}: the phosphopeptide centered on the modified residue; it should be at least a 15-mer, compatible with SIGNOR and PsP database notation;

-   [**difference**]{style="color:orange"}: representing the fold-change in gene expression among two conditions; e.g. the difference between treated and control sample;

-   [**logpval**]{style="color:orange"}: the p-value associated to the statistical test assessing the significance of your comparisons;

-   [**significant**]{style="color:orange"}: a column containing a '+' if the gene is significantly modulated, NA otherwise;

::: {#Table3}
Phosphoproteomics data example
:::

```{r}
DT::datatable(phospho_toy_df, options = list(pageLength = 3))
```

# SignalingProfiler output

The output of SignalingProfiler is a list composed of different elements `toy_sp_output`:

> Network in igraph format `toy_sp_output$igraph_network`

> Table of the proteins included in the network with attributes `toy_sp_output$nodes_df`

-   Protein identifiers: [**UniProt ID**]{style="color:orange"} and [**gene name**]{style="color:orange"};

-   Two different activity scores:

    -   [**final_score**]{style="color:orange"}: it is the activity derived from experimental data;
    -   [**carnival_activity**]{style="color:orange"}: it is the activity computed by CARNIVAL algorithm ranging between -100 and +100; usually it has the *same sign* as the **final_score**, but sometimes CARNIVAL changes the node activity because the neighbour proteins suggest the opposite activity sign;
    -   [**discordant**]{style="color:orange"}: it is TRUE if **final_score** and **carnival_activity** have opposite sign;

-   Molecular function annotation (**mf**);

```{r}
DT::datatable(toy_sp_output$nodes_df, options = list(pageLength = 3))
```

> Table of edges included in the network with biologically relevant attributes `toy_sp_output$edges_df`

-   Uniprot IDs of the nodes connected ([**source**]{style="color:orange"} and [**target**]{style="color:orange"});

-   [**sign**]{style="color:orange"} reporting if the interaction is activatory (1) or inhibitory (-1);

-   [**carnival_weight**]{style="color:orange"}: since CARNIVAL may return more than one solustion, this attribute reports the frequency of the edge in the different solutions returned (e.g. 100 means that the edge is present in all the solutions!);

-   annotation from phosphoproteomics data:

    -   [**aminoacid**]{style="color:orange"}: reports the phosphosites in SIGNOR and PsP matching that interaction; if the phosphosite has a \* it means that it is *significantly modulated among your two conditions*;

    -   [**FC**]{style="color:orange"}: reports the fold-change of phosphorylation among your two conditions of the phosphosite matched on the interaction;

    -   [**is quantified**]{style="color:orange"} is TRUE if you quantified the phosphosite matching that edge in your phosphoproteomic data set;

    -   [**is significant**]{style="color:orange"} is TRUE if the quantified phosphosite matching that edge in your phosphoproteomic data set is significantly modulated;

```{r}
DT::datatable(toy_sp_output$edges_df, options = list(pageLength = 3))
```

------------------------------------------------------------------------

# S1. Infer protein activities from multi-omics data {#s1.-infer-protein-activities-from-multi-omics-data}

SignalingProfiler allows the user to infer protein activities from omic data comining:

-   **Footprint-based analysis**: you infer the activity of a transcription factor (or kinases and phosphatases) from the modulation of its targets;

-   **Phosphoscore analysis**: you infer the activity of phosphoproteins from the modulation of their regulatory phosphosites;

## Footprint-based analysis

Footprint-based analysis derives protein activities *from the modulation of downstream targets* using the VIPER[^2] algorithm. In particular:

[^2]: Alvarez MJ, Shen Y, Giorgi FM, Lachmann A, Ding BB, Ye BH, Califano A. Functional characterization of somatic mutations in cancer using network-based inference of protein activity. Nat Genet. 2016 Aug;48(8):838-47. doi: 10.1038/ng.3593. Epub 2016 Jun 20. PMID: 27322546; PMCID: PMC5040167.

-   ***TFEA (Transcription Factor Enrichment Analysis)*** infers transcription factors activity from the modulation of target genes in transcriptomics data;

-   ***KSEA (Kinase Substrates Enrichment Analysis)*** infers kinases/phosphatases activity from the modulation of target phosphosites in phosphoproteomics data;

The set of regulated analytes of a TF/KIN/PHOS is called *regulon*.

#### Regulons

::: {.info-box .tip}
**SignalingProfiler built-in regulons**

-   TFs-genes regulons (`tfea_db_human`, `tfea_db_human_collectri`) are retrieved from DoRothEA[^3] R Package (confidence: A) and from SIGNOR[^4] or from Collectri[^5] a new comprehensive resource.

-   KIN/PHOS-phosphosites regulons (`ksea_db_human`) are derived from OmniPath[^6];

    -   Given the recent publication of the [Serine-Threonine-Tyrosin Kinome Atlas](https://www.nature.com/articles/s41586-022-05575-3)[^7][^8] we integrated high confidence regulons in the `ksea_db` derived from this work. If you want to extend your data with the atlas, set `integrated_regulons = TRUE`.
:::

[^3]: Garcia-Alonso L, Holland CH, Ibrahim MM, Turei D, Saez-Rodriguez J. Benchmark and integration of resources for the estimation of human transcription factor activities. Genome Res. 2019 Aug;29(8):1363-1375. doi: 10.1101/gr.240663.118. Epub 2019 Jul 24. Erratum in: Genome Res. 2021 Apr;31(4):745. doi: 10.1101/gr.275408.121. PMID: 31340985; PMCID: PMC6673718.

[^4]: Lo Surdo P, Iannuccelli M, Contino S, Castagnoli L, Licata L, Cesareni G, Perfetto L. SIGNOR 3.0, the SIGnaling network open resource 3.0: 2022 update. Nucleic Acids Res. 2023 Jan 6;51(D1):D631-D637. doi: 10.1093/nar/gkac883. PMID: 36243968; PMCID: PMC9825604.

[^5]: Müller-Dott S, Tsirvouli E, Vazquez M, Ramirez Flores RO, Badia-I-Mompel P, Fallegger R, Türei D, Lægreid A, Saez-Rodriguez J. Expanding the coverage of regulons from high-confidence prior knowledge for accurate estimation of transcription factor activities. Nucleic Acids Res. 2023 Nov 10;51(20):10934-10949. doi: 10.1093/nar/gkad841. PMID: 37843125; PMCID: PMC10639077.

[^6]: Türei D, Korcsmáros T, Saez-Rodriguez J. OmniPath: guidelines and gateway for literature-curated signaling pathway resources. Nat Methods. 2016 Nov 29;13(12):966-967. doi: 10.1038/nmeth.4077. PMID: 27898060.

[^7]: Johnson JL, Yaron TM, Huntsman EM, Kerelsky A, Song J, Regev A, Lin TY, Liberatore K, Cizin DM, Cohen BM, Vasan N, Ma Y, Krismer K, Robles JT, van de Kooij B, van Vlimmeren AE, Andrée-Busch N, Käufer NF, Dorovkov MV, Ryazanov AG, Takagi Y, Kastenhuber ER, Goncalves MD, Hopkins BD, Elemento O, Taatjes DJ, Maucuer A, Yamashita A, Degterev A, Uduman M, Lu J, Landry SD, Zhang B, Cossentino I, Linding R, Blenis J, Hornbeck PV, Turk BE, Yaffe MB, Cantley LC. An atlas of substrate specificities for the human serine/threonine kinome. Nature. 2023 Jan;613(7945):759-766. doi: 10.1038/s41586-022-05575-3. Epub 2023 Jan 11. PMID: 36631611; PMCID: PMC9876800.

[^8]: Yaron-Barir TM, Joughin BA, Huntsman EM, Kerelsky A, Cizin DM, Cohen BM, Regev A, Song J, Vasan N, Lin TY, Orozco JM, Schoenherr C, Sagum C, Bedford MT, Wynn RM, Tso SC, Chuang DT, Li L, Li SS, Creixell P, Krismer K, Takegami M, Lee H, Zhang B, Lu J, Cossentino I, Landry SD, Uduman M, Blenis J, Elemento O, Frame MC, Hornbeck PV, Cantley LC, Turk BE, Yaffe MB, Johnson JL. The intrinsic substrate specificity of the human tyrosine kinome. Nature. 2024 May;629(8014):1174-1181. doi: 10.1038/s41586-024-07407-y. Epub 2024 May 8. PMID: 38720073; PMCID: PMC11136658.

::: {.info-box .important}
**Create you own TFEA/KSEA custom regulons**

SignalingProfiler 2.0 updates its regulons (regulatory networks) twice a year. If the user want to use updated regulons, we implemented functions taking the information from different resources and making them SignalingProfiler compliant.

```{r eval = FALSE}
tfea_regulons <- create_tfea_regulons(resources = c('SIGNOR', 'Dorothea'),
                                      organism = 'human')
write_tsv(tfea_regulons, '../custom_regulons/tfea_custom_regulons.tsv')

ksea_regulons <- create_ksea_regulons(resources = c('SIGNOR', 'Omnipath'), 
                                      organism = 'human')
write_tsv(ksea_regulons, '../custom_regulons/ksea_custom_regulons.tsv')
```
:::

#### Transcription factors' activity inference

```{r eval = FALSE}
tf_activity_foot <- run_footprint_based_analysis(omic_data = tr_toy_df, 
                                              analysis = 'tfea', 
                                              organism = 'human', 
                                              reg_minsize = 10, 
                                              exp_sign = FALSE,
                                              collectri = FALSE,
                                              hypergeom_corr = TRUE,
                                              GO_annotation = TRUE, 
                                              correct_proteomics = TRUE, 
                                              prot_df = prot_toy_df, 
                                              custom = FALSE,
                                              custom_path = NULL)
# Set custom = TRUE and specify your custom regulons path in custom_path = '../custom_regulons/tfea_custom_regulons.tsv', if you have custom regulons!
```

#### Kinases/Phosphatases activity inference

```{r eval = FALSE}
kin_phos_activity_foot <- run_footprint_based_analysis(omic_data = phospho_toy_df, 
                                              analysis = 'ksea', 
                                              organism = 'human', 
                                              reg_minsize = 5, 
                                              exp_sign = FALSE, 
                                              integrated_regulons = TRUE, 
                                              hypergeom_corr = TRUE,
                                              GO_annotation = TRUE, 
                                              correct_proteomics = TRUE, 
                                              prot_df = prot_toy_df, 
                                              custom = FALSE,
                                              custom_path = NULL)

# Set custom = TRUE and specify your custom regulons path in custom_path = '../custom_regulons/ksea_custom_regulons.tsv', if you have custom regulons!
```

## PhosphoScore analysis

PhosphoScore computation exploits: - the experimental fold-change of the phosphosites in phosphoproteomics; - the regulatory role of phosphosites annotated in SIGNOR and PsP databases;

::: orange-box
#### Regulatory phosphosites sources

The information about how phosphosites regulated the protein they are on is retrieved from SIGNOR and PsP databases (`good_phos_df_human_act`, `good_phos_df_human_act_aapos`).
:::

::: {.info-box .important}
SignalingProfiler 2.0 updates its regulons (regulatory networks) twice a year. If the user want to use updated information it can create its own information about regulatory phosphosites. Importantly, if you want to include PsP information you have to manually download from PsP database the Regulatory_sites file.

```{r eval = FALSE}
reg_phosphosites <- get_phosphoscore_info(resources = c('SIGNOR', 'PsP'), 
                      organism = 'human', 
                      psp_reg_site_path = '../../revisions/input/Regulatory_sites_2023-08-24',
                      only_activatory = TRUE)

write_tsv(reg_phosphosites, '../custom_regulons/act_phosphosites.tsv')
```
:::

#### Infer the activity of phosphorylated proteins

```{r eval = FALSE}
phosphoscore_df <- phosphoscore_computation(phosphoproteomic_data = phospho_toy_df, 
                                            organism = 'human', 
                                            activatory = TRUE , 
                                            GO_annotation = TRUE,
                                            custom = FALSE, 
                                            custom_path = NULL)
# Set custom = TRUE and specify your custom regulons path in custom_path = '../custom_regulons/ksea_custom_regulons.tsv', if you have custom regulons!

```

## Final score computation

Transcription factors, kinases and phosphatases could have an activity derived from both their targets transcripts/genes and from their regulatory phosphosites. The **final score computation** integrates these two scores. Importantly, the computation should be done separately from transcription factors, kinases, and phosphatases.

```{r eval = FALSE}
# for transcription factors
combined_tf <- combine_footprint_and_phosphoscore(footprint_output = tf_activity_foot,
                                                  phosphoscore_df =  phosphoscore_df, 
                                                  analysis =  'tfea')
toy_tf <- combined_tf

# for kinases and phosphatases
combined_kin_phos <- combine_footprint_and_phosphoscore(footprint_output = kin_phos_activity_foot,
                                                  phosphoscore_df =  phosphoscore_df, 
                                                  analysis =  'ksea')
toy_kin <- combined_kin_phos
```

Then, isolate the phosphorylated proteins of the PhosphoScore technique:

```{r eval = FALSE}
toy_other <- phosphoscore_df %>%
  dplyr::filter(mf == 'other') %>%
  dplyr::rename(final_score = phosphoscore) %>%
  dplyr::mutate(method = 'PhosphoScore')
```

Then you can combine all the information in a final activity table:

```{r eval = FALSE}
# create a unified 'activity modulation' table for the next steps
toy_prot_activity_df <- dplyr::bind_rows(toy_tf, toy_kin, toy_other) %>%
  select(UNIPROT, gene_name, mf, final_score, method)
```

> Final score table example example

```{r}
DT::datatable(toy_prot_activity_df, options = list(pageLength = 3))
```

##### Example of Step1 result

```{r fig.align='center', fig.width=5, fig.height=7}

toy_prot_activity_df$mf <- factor(toy_prot_activity_df$mf, levels = c('tf', 'kin', 'phos', 'other'))

ggplot(toy_prot_activity_df,
       aes(x = fct_reorder(gene_name, final_score), y = final_score)) +
  geom_bar(stat = "identity", aes(fill = final_score), alpha = 1) +
  facet_grid(mf ~ ., space ='free_y', scales = 'free') +
  theme_classic() +
  scale_fill_gradient2(low = "#89ABD6", high = "#FF6A72",
                       mid = "whitesmoke", midpoint = 0) +
  theme(text = element_text(size= 6),
        axis.text.x = element_text(angle = 0, vjust = 1, size = 5),
        legend.position="bottom",
        legend.title = element_blank()) +
  xlab('') +
  coord_flip()+
  ylab('Final score') 
```

::: {.info-box .tip}
*SignalingProfiler* 2.0 offers different techniques to derive the activity of proteins. It is up to you and the data you have the choice of the methods and the combination of methods to use. Importantly, the analysis is flexible and powerful. For example, if you have only phosphoproteomics data, you can still infer the activity of transcription factors using their regulatory phosphosites in the PhosphoScore analysis!!
:::

The end of this first step should be a single table containing all the proteins for which you inferred the activity with their molecular function. So each protein should have a single value deriving eventually from the combination of the two methods.

------------------------------------------------------------------------

# S2. Connect inferred proteins in a causal network

In this step, SignalingProfiler connects the proteins of Step1 to user-specified receptor(s). If you do not have a starting point, you can still use SignalingProfiler using the inverseCARNIVAL algorithm.

::: orange-box
#### Prior Knowledge Network

To connect the proteins, SignalingProfiler uses the prior information about molecular interactions stored in SIGNOR and PhosphoSitePlus databases. Briefly, every PKN interaction is binary, directed (has a regulator and a target of the regulation), and signed (representing either an up- or a down-regulation).
:::

::: {.info-box .tip}
**Built-in objects**

The information is stored in different built-in objects that can containg all interactions `PKN_human_ind` or only direct interactions (`PKN_human_dir`)
:::

::: {.info-box .important}
**Custom PKN**

SignalingProfiler 2.0 updates its prior knowledge network twice a year. We offer the user an interface to Omnipath and SIGNOR to assemble an updated PKN in SignalingProfiler compliant format. Remember, if you want to include PsP you have to provide its manually downloaded files!

```{r eval = FALSE}
create_PKN(database = c('SIGNOR', 'PsP'), #add also 'Omnipath' or 'Ser/Thr_Kinome_Atlas'
           direct = TRUE,
           organism = 'human', 
           psp_reg_site_path = '../../revisions/input/Regulatory_sites_2023-08-24',
           psp_kin_sub_path = '../../revisions/input/Kinase_Substrate_Dataset_2023-08-24', 
           file_path =  '../custom_regulons/custom_PKN.RDS')
```
:::

> Choose and preprocess the PKN

The first step is to choose the Prior Knowledge Network (PKN).

Signaling Profiler allow you to use built-in PKNs for **mouse** and **human** or to exploit a **custom PKN.** For the custom PKN you have to provide the path of the file.

::: {.info-box .tip}
For **human** you can choose between a PKN containing the interactions from only databases, or a PKN containing interactions also derived from the [kinome atlas](https://www.nature.com/articles/s41586-022-05575-3)[^9][^10], specifying the `with_atlas = TRUE`. In our benchmarking it resulted in a network with an artificial number of hubs, but it could be still useful if you are interested in not known phosphorylation events!
:::

[^9]: Johnson JL, Yaron TM, Huntsman EM, Kerelsky A, Song J, Regev A, Lin TY, Liberatore K, Cizin DM, Cohen BM, Vasan N, Ma Y, Krismer K, Robles JT, van de Kooij B, van Vlimmeren AE, Andrée-Busch N, Käufer NF, Dorovkov MV, Ryazanov AG, Takagi Y, Kastenhuber ER, Goncalves MD, Hopkins BD, Elemento O, Taatjes DJ, Maucuer A, Yamashita A, Degterev A, Uduman M, Lu J, Landry SD, Zhang B, Cossentino I, Linding R, Blenis J, Hornbeck PV, Turk BE, Yaffe MB, Cantley LC. An atlas of substrate specificities for the human serine/threonine kinome. Nature. 2023 Jan;613(7945):759-766. doi: 10.1038/s41586-022-05575-3. Epub 2023 Jan 11. PMID: 36631611; PMCID: PMC9876800.

[^10]: Yaron-Barir TM, Joughin BA, Huntsman EM, Kerelsky A, Cizin DM, Cohen BM, Regev A, Song J, Vasan N, Lin TY, Orozco JM, Schoenherr C, Sagum C, Bedford MT, Wynn RM, Tso SC, Chuang DT, Li L, Li SS, Creixell P, Krismer K, Takegami M, Lee H, Zhang B, Lu J, Cossentino I, Landry SD, Uduman M, Blenis J, Elemento O, Frame MC, Hornbeck PV, Cantley LC, Turk BE, Yaffe MB, Johnson JL. The intrinsic substrate specificity of the human tyrosine kinome. Nature. 2024 May;629(8014):1174-1181. doi: 10.1038/s41586-024-07407-y. Epub 2024 May 8. PMID: 38720073; PMCID: PMC11136658.

```{r eval = FALSE}
PKN_table <- choose_PKN(organism = 'human', 
                        with_atlas = FALSE,
                        direct = TRUE,
                        custom = FALSE,
                        custom_path = NULL)

# If you want to use your custom PKN put custom = TRUE and custom_path = '../custom_regulons/custom_PKN.RDS'
```

::: {.info-box .important}
Since **PKN** interactions come from different experimental systems, a good practice is to keep only the ones involving analytes expressed in your system, so quantified in at least one of your omics data sets.

```{r eval = FALSE}
PKN_expressed <- preprocess_PKN(omics_data = list(tr_toy_df, prot_toy_df, phospho_toy_df),
                                PKN_table = PKN_table)
```
:::

## Build a naïve network

To speed up the analysis, we want to restrict the PKN interactome to the neighborhood of the inferred proteins, generating a **naïve network**. It is a graph connecting your proteins through **ALL** the possible **SHORTEST** causal paths of a user-specified length (1 to 4). We don't consider the causality of the edges, just distance. As such, in the naïve network there may be two paths with same length, but different causal meaning.

::: {.info-box .tip}
SignalingProfiler 2.0 offers three types of **naïve networks**, but the benchmarking process revealed the two-layered as optimal. We suggest to explore also the three-layered!
:::

```{r eval = FALSE}
# divide proteins according to the molecular function
kin_phos_other <- toy_prot_activity_df %>% 
  dplyr::filter(mf %in% c('kin', 'phos', 'other'))
tfs <- toy_prot_activity_df %>% 
  dplyr::filter(mf == 'tf')

# create the naïve network
two_layers_toy <- two_layer_naive_network(starts_gn = c('MTOR', 'AMPK'),
                             intermediate_gn = kin_phos_other$gene_name,
                             targets_gn = tfs$gene_name, 
                             PKN_table = PKN_expressed, #or PKN_human_dir
                             max_length_1 = 3, 
                             max_length_2 = 4, 
                             connect_all = TRUE, 
                             rds_path = './two_layers_naive.rds',
                             sif_path = './two_layers_naive.sif')
```

##### Prepare input for CARNIVAL optimization

Once you have created the naïve network you have to prepare the result for the next step. An example is available in `carnival_input_toy` variable.

```{r eval = FALSE}
two_layers_toy <- readRDS('./two_layers_naive.rds')

receptor_list <- list('MTOR' = -1, 'AMPK' = 1)

carnival_input_toy <- prepare_carnival_input(two_layers_toy, 
                                             toy_prot_activity_df, 
                                             receptor_list, 
                                             organism = 'human')
                                         
```

> CARNIVAL input protein table example

```{r eval = TRUE, include = FALSE}
DT::datatable(carnival_input_toy, options = list(pageLength = 3))
```

------------------------------------------------------------------------

## CARNIVAL optimization

CARNIVAL algorithm optimizes the naïve network in a context-specific model. This means that the sign of the edges will be coherent with the context-specific activity of the Step 1.

::: {.info-box .caution}
#### ILP Solver installation

CARNIVAL requires the ILP solver to be installed. We suggest [***cplex*** by IBM](https://www.ibm.com/products/ilog-cplex-optimization-studio). A similar performance is observed using the [Gurobi solver](https://portal.ampl.com/user/ampl/download/gurobi). To run the analysis you have to specify the **name** of the solver, so that we can set the default option for the run.

```{r eval = FALSE}
solver = 'cplex'
carnival_options = default_CARNIVAL_options(solver)
```

Then, you have to manually specify the path of the solver.

```{r eval = FALSE}
#for Windows
carnival_options$solverPath = "C:/Program Files/CPLEX_solver/cplex/bin/x64_win64/cplex.exe" 

#for macOS
carnival_options$solverPath = '/Applications/CPLEX_Studio221/cplex/bin/x86-64_osx/cplex' 

#for Linux
carnival_options$solverPath = '/opt/ibm/ILOG/CPLEX_Studio2211/cplex/bin/x86-64_linux/cplex'
```

You can change the options used by the solver (try first with the default).

```{r eval = FALSE}
carnival_options$mipGAP <- 0.05
carnival_options$timelimit <- 3600
carnival_options$cplexMemoryLimit <- 8192
```
:::

::: {.info-box .tip}
*SignalingProfiler* offers 4 versions of CARNIVAL algorithm for the optimization. Three version work with a known **starting point** of the model, one without (inverseCARNIVAL). In the benchmarking, we identified the *two-shots CARNIVAL* as the optimal way of running the analysis in terms of recapitulated proteins and phosphorylations within the network.
:::

To run CARNIVAL algorithm: - create a tibble with the starting point(s) of the model (`source_df`); - Create a tibble with the ending points of the model (`target_df`); - Provide the *naïve network* in SIF format (Step 2 creates the file in your working directory) (`naïve_network`; - Provide the whole inferred proteins tibble (`proteins_df`); - Provide the CARNIVAL options you created in the former step (`carnival_options`); Moreover, according to the PKN you used you have to set the `direct` and `with_atlas` parameters in the function.

#### Two-shots CARNIVAL:

1.  Connect the pertubed node(s) to kinases, phosphatases and other signaling proteins;

2.  Connect the kinases, phosphatases and other signaling proteins to transcription factors.

3.  Compute the union of the two graphs

```{r eval = FALSE}

# FIRST RUN: RECEPTOR to KIN, PHOS, OTHERS
receptors_df <- carnival_input_toy %>% dplyr::filter(mf == 'rec')

target1_df <- carnival_input_toy %>%
  dplyr::filter(mf %in% c('kin', 'phos', 'other'))

two_layers_toy_df <- readr::read_tsv('./two_layers_naive.sif',
                                 col_names = c('source', 'interaction', 'target'))

output1 <- run_carnival_and_create_graph(source_df = receptors_df,
                                         target_df = target1_df,
                                         naive_network = unique(two_layers_toy_df),
                                         proteins_df = carnival_input_toy,
                                         organism = 'human',
                                         carnival_options = carnival_options,
                                         files = FALSE,
                                         direct = FALSE,
                                         with_atlas = TRUE)


# SECOND RUN: from KIN, PHOS, OTHERS to TFs
run1_output_nodes <- convert_output_nodes_in_next_input(output1)

source_df <- run1_output_nodes %>%
  dplyr::filter(mf %in% c('kin', 'phos', 'other'))

target2_df <- carnival_input_toy %>%
  dplyr::filter(mf == 'tf')

output2 <- run_carnival_and_create_graph(source_df = source_df,
                                         target_df = target2_df,
                                         naive_network = unique(two_layers_toy_df),
                                         proteins_df = carnival_input_toy,
                                         organism = 'human',
                                         carnival_options = carnival_options,
                                         direct = FALSE,
                                         with_atlas = TRUE,
                                         files = FALSE)
                                         
# UNION OF RUN1 and RUN2 graphs 
union <- union_of_graphs(graph_1 = output1$igraph_network, 
                         graph_2 = output2$igraph_network, 
                         proteins_df = carnival_input_toy, 
                         files = TRUE, 
                         path_sif = './optimized_network.sif', 
                         path_rds = './optimized_object.rds')
```

## Map phosphoproteomics

After CARNIVAL optimization, SignalingProfiler maps phosphoproteomics data on the signaling edges of the model for a better biological interpretation of the result.

```{r eval = FALSE}
optimized_object_rds <- readRDS('./optimized_object.rds')

toy_sp_output <- expand_and_map_edges(optimized_graph_rds = optimized_object_rds, 
                     organism = 'human',
                     phospho_df = phospho_toy_df,
                     files = TRUE,
                     direct = FALSE, 
                     with_atlas = TRUE,
                     path_sif = 'optimized_network_validated.sif',
                     path_rds = 'optimized_object_validated.rds')
```

> Example of experimentally validated edges

```{r }
DT::datatable(toy_sp_output$edges_df %>% dplyr::filter(is_quantified == TRUE), 
              options = list(pageLength = 5))

```

------------------------------------------------------------------------

# S3. Connect phenotypes to the final model

To make the model functionally interpretable, you can connect phenotypes to the model proteins and infer the activity of phenotypes integrating the signaling axes in the model contributing to their activation/inhibition.

> We exploit the [**ProxPath**](https://www.nature.com/articles/s41380-023-02317-3)[^11] algorithm to connect SIGNOR phenotypes to the model proteins and the **PhenoScore** algorithm, to infer the phenotypes activity.

[^11]: Alvarez MJ, Shen Y, Giorgi FM, Lachmann A, Ding BB, Ye BH, Califano A. Functional characterization of somatic mutations in cancer using network-based inference of protein activity. Nat Genet. 2016 Aug;48(8):838-47. doi: 10.1038/ng.3593. Epub 2016 Jun 20. PMID: 27322546; PMCID: PMC5040167.

::: {.info-box .tip}
#### <span style="color:orange">Crucial concepts of PhenoScore algorithm</span>

In the PhenoScore computation we indirectly connect proteins to the phenotypes. You can choose the path_length between proteins an phenotype, from 2 to 4.

Crucial concepts: - a protein can regulate a phenotype with multiple paths; - the phenotype will be regulated by activating and inhibitory paths;

Here there are the steps of the algorithm:

1.  **Select significant close phenotypes from ProxPath:** select from the ProxPath table the significantly close proteins next to your phenotypes of interest (key parameters are `zscore_threshold`, `stat`)

2.  **Remove randomly regulated phenotypes:** given your protein list (`protein_df`), we sample a random protein list with the same number of proteins and compute the number of activating and inhibitory paths over the phenotype of interest from both lists. If the random list produces the same number of paths of your input list over a phenotype of interest, the phenotype is discarded, because it is regulated at random (key parameters are:`n_random`, `pvalue_threshold`).

3.  **PhenoScore computation:** we compute the average of the activity of proteins regulating the same phenotype, with three considerations: (i) if two independent regulators are connected in the network (`sp_graph`), consider the most downstream (`remove_cascade = TRUE`); (ii) we weight proteins according to their number of paths over the phenotype (since they are more resilient, `node_idx = TRUE`); (iii) the activity considered can be both experimentally derived or derived from CARNIVAL algorithm (`use_carnival_activity = TRUE`).
:::

## ProxPath preprocessing

To make the ProxPath protein-phenotypic relations context-specific, we remove interactions involving proteins not quantified in your proteomics data.

```{r eval = FALSE}
pheno_table_distances <- phenoscore_network_preprocessing(proteomics = prot_toy_df,
                                                          phospho = phos_toy_df)

```

#### Choose phenotypes

Check the available phenotypes from this table and create a vector of desired phenotypes. Alternatively, you can perform the analysis on all phenotypes.

```{r eval = TRUE}
DT::datatable(proxpath_phenotypes, options = list(pageLength = 3))
```

## Run PhenoScore

```{r eval = FALSE}

# example phenotypic vector
desired_phenotypes <- c('APOPTOSIS',
                        'CELL_DEATH',  'CELL_GROWTH', 'CELL_CYCLE_BLOCK',
                        'DNA_REPAIR',
                        'PROLIFERATION', 'IMMORTALITY', 'SURVIVAL')

toy_phenoscore_output<- phenoscore_computation(proteins_df = toy_sp_output$nodes_df,
                                               desired_phenotypes = desired_phenotypes,
                                               pheno_distances_table = pheno_table_distances, 
                                               sp_graph = toy_sp_output$igraph_network,
                                               # closeness of proteins to phenotypes
                                               path_length = 3,
                                               stat = 'mean',
                                               zscore_threshold = -1.96,
                                               # exclude random phenotypes
                                               n_random = 1000,
                                               pvalue_threshold = 0.05,
                                               # optimized network  specificity
                                               remove_cascade = TRUE,
                                               node_idx = FALSE,
                                               use_carnival_activity = FALSE, 
                                               create_pheno_network = TRUE)

writeRDS(toy_phenoscore_output, './toy_phenoscore_output.RDS')
```

##### PhenoScore output

> Visualize PhenoScore as barplot

```{r fig.align='center', fig.width=5, fig.height=5}

toy_phenoscore_output$table_phenotypes -> phenoscore_df1
phenoscore_df1 <- phenoscore_df1 %>% dplyr::mutate(reg = ifelse(phenoscore < 0, 'down', 'up'))

  color_list <- list('down' = '#407F7F', 'up' = '#D46A6A')

  ggplot2::ggplot(phenoscore_df1,
                  ggplot2::aes(x = forcats::fct_reorder(EndPathways, phenoscore),
                               y = phenoscore, fill = reg))+
    ggplot2::geom_bar(stat = 'identity', alpha = 0.8)+
    ggplot2::scale_fill_manual(values = color_list, labels = names(color_list)) +
    ggplot2::ggtitle(paste0('Phenoscore')) +
    ggplot2::ylab("phenotype modulation") +
    ggplot2::xlab("") +
    ggplot2::theme_bw()+
    ggplot2::theme(legend.title = element_blank(),
          legend.position = 'none',
          plot.title=element_text(hjust = 0.5),
          panel.grid.minor = element_blank(),
          axis.text.y = element_text( size = 14, face = 'bold'),
          axis.text.x=element_text(size=10, angle=0, vjust=0.5, hjust=0.5))+
    ggplot2::coord_flip()
```

> Visualize regulators of phenotypes

```{r}
sub_table <- toy_phenoscore_output$table_regulators %>% dplyr::select(EndPathways, Effect, regulators) 
DT::datatable(sub_table, options = list(pageLength = 3))
```

# Visualization

To clearly visualize the network, we suggest to optimize the model for the last time on the phenotypic activity.

```{r eval = FALSE}
solver = 'cplex'
carnival_options <- default_CARNIVAL_options(solver)

opt1 <- optimize_pheno_network(sp_object = toy_phenoscore_output,
                               organism = 'human',
                               phospho_df = phospho_toy_df,
                               carnival_options = carnival_options,
                               files = TRUE,
                               direct = TRUE,
                               with_atlas = FALSE,
                               path_sif = './pheno_opt1.sif',
                               path_rds = './pheno_opt1.rds')

opt1_graph <- format_for_visualization(opt1)

# Visualization in Cytoscape
RCy3::createNetworkFromIgraph(igraph=opt1$sp_object_phenotypes$igraph_network,
                              title = 'My model',
                              collection = 'My collection')
data_path <- system.file("extdata", "SP_pheno_layout.xml", package = "SignalingProfiler")
RCy3::importVisualStyles(filename = data_path)
RCy3::setVisualStyle('SP_pheno_layout')
```

::: {.info-box .tip}
SignalingProfiler package offers .XML files for setting Cytoscape style:

-   **phospho_layout**: highlights interactions representing significant phosphorylation events;

-   **pheno_layout**: visualize the whole model in hierarchical and nice way.
:::

```{r eval = FALSE}
# Phospho layout
data_path <- system.file("extdata", "SP_phospho_layout.xml", package = "SignalingProfiler")
RCy3::importVisualStyles(filename = data_path)
RCy3::setVisualStyle('SP_phospho_layout')

# Pheno layout
data_path <- system.file("extdata", "SP_pheno_layout.xml", package = "SignalingProfiler")
RCy3::importVisualStyles(filename = data_path)
RCy3::setVisualStyle('SP_pheno_layout')
```

> Examples of SignalingProfiler 2.0 resulting network in NDEX:
>
> -    Metformin network: <https://www.ndexbio.org/viewer/networks/fa22e724-b54b-11ee-8a13-005056ae23aa>
>
> -   EGF network: <https://www.ndexbio.org/viewer/networks/59ab8c7b-0611-11ef-9621-005056ae23aa>
>
> -   Flt3 inhibition network: <https://www.ndexbio.org/viewer/networks/bde743d2-0613-11ef-9621-005056ae23aa>

# Functional circuits {#functional-circuits}

A novel feature is the possibily to extract functional circuits from a desired start nodes to a set of end nodes (e.g., phenotypes). ***k*** is the max path length between two proteins in the circuit.

```{r eval = FALSE}
opt1_list <- readRDS('./pheno_opt1.rds')

opt1_list$sp_object_phenotypes <- format_for_visualization(opt1_list)

# Circuits on example phenotypes
phenotypes <- c('PROLIFERATION', 'AUTOPHAGY')
start_nodes <- c('MTOR', 'AMPK')

# Circuit on autophagy, ribosome and translation
circuit <- pheno_to_start_circuit(SP_object = opt1_list$sp_object_phenotypes,
                                  start_nodes = start_nodes,
                                  phenotypes = phenotypes,
                                  k = 5,
                                  start_to_top = TRUE)

RCy3::createNetworkFromIgraph(igraph=circuit,
                              title = 'My network',
                              collection = 'Metformin')
RCy3::setVisualStyle('SP_pheno_layout')
```

> Functional circuits examples

![**Signaling Profiler Workflow**](../img/Circuit_example.png)

# Conclusion {.unnumbered}

::: {#box1 .green-box}
This is a tutorial for the usage of SignalingProfiler 2.0. For any doubt please contact us at: [*veronica.venafra97\@gmail.it*](mailto:veronica.venafra97@gmail.it){.email}, [*livia.perfetto\@uniroma1.it*](mailto:livia.perfetto@uniroma1.it){.email}, [*francesca.sacco\@uniroma2.it*](mailto:francesca.sacco@uniroma2.it){.email}.
:::

# R session info {.unnumbered}

```{r session info, comment=""}
xfun::session_info()
```

# References {.unnumbered}
